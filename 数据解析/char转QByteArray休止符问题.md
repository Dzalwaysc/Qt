# 现象描述

```c++
int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    unsigned char buf[] = {0x24, 0x54, 0x58, 0x58, 0x58,
                  0x00, 0x52,
                  0x05, 0xd4, 0x60,
                  0x60,
                  0x05, 0xd4, 0x69,
                  0x00, 0x00,
                  0x01, 0xf0,
                  0xa4, 0x30, 0x20, 0x34, 0x20, 0x30, 0x20, 0x30,
                  0x20, 0x30, 0x20, 0x30, 0x20, 0x30, 0x20, 0x30,
                  0x20, 0x30, 0x20, 0x30, 0x20, 0x30, 0x20, 0x34,
                  0x34, 0x38, 0x20, 0x30, 0x20, 0x30, 0x20, 0x30,
                  0x20, 0x30, 0x20, 0x30, 0x20, 0x30, 0x20, 0x30,
                  0x20, 0x2d, 0x32, 0x38, 0x36, 0x33, 0x33, 0x31,
                  0x31, 0x35, 0x34, 0x20, 0x2d, 0x32, 0x38, 0x36,
                  0x33, 0x33, 0x31, 0x31, 0x35, 0x34,
                  0x00, 0x7a};

    char* chBuf = reinterpret_cast<char*>(buf);

    QByteArray recvMsg(chBuf);
    qDebug()<<recvMsg;
    qDebug()<<recvMsg.toHex();
    return a.exec();
}
输出: "$TXXX"
输出: "2454585858"
```
可以发现，从char转QByteArray的时候，当遇到休止符0x00时，就停止转换了

## 问题解决
```c++
QByteArray recvMsg(chBuf);
改成
QByteArray recvMsg(chBuf, sizeof(chBuf)) 
```